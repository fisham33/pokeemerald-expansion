# Implementation Notes

Technical details about how the Pokemon Emerald Live Tracker works.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                   Build Process                          │
│  pokeemerald-expansion → make → ROM + ELF → make syms   │
│                                              ↓           │
│                                     pokeemerald.sym      │
└─────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────┐
│                  mGBA Emulator                           │
│  ┌─────────────────────────────────────────────┐       │
│  │  tracker.lua (Main Script)                  │       │
│  │  - Loads pokeemerald.sym                    │       │
│  │  - Maps symbol names → addresses            │       │
│  │  - Reads memory via emu:getMemoryBlock()    │       │
│  │  ├─ modules/pokemon_decrypt.lua             │       │
│  │  ├─ modules/species_data.lua (1622 species) │       │
│  │  └─ modules/move_data.lua (900+ moves)      │       │
│  │                                              │       │
│  │  Every 60 frames (1 second):                │       │
│  │  - Read party, badges, boxes                │       │
│  │  - Decrypt Pokemon data                     │       │
│  │  - Export to tracker_data.json              │       │
│  └─────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────┘
                        ↓ JSON File I/O
┌─────────────────────────────────────────────────────────┐
│              Web Frontend (Browser)                      │
│  ┌─────────────────────────────────────────────┐       │
│  │  index.html + style.css + script.js          │       │
│  │                                              │       │
│  │  Every 1 second:                             │       │
│  │  - Fetch tracker_data.json (cache-busted)   │       │
│  │  - Parse JSON                                │       │
│  │  - Update DOM:                               │       │
│  │    • Trainer info                            │       │
│  │    • Party Pokemon (with stats, moves, HP)  │       │
│  │    • Badges (visual indicators)             │       │
│  │    • PC boxes                                │       │
│  └─────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────┘
```

## Symbol File Format

Generated by `make syms`, format: `ADDRESS TYPE SIZE NAME`

Example:
```
02024744 g 00000001 gPlayerPartyCount
02024748 g 00000258 gPlayerParty
0203CC40 g 00000004 gPokemonStoragePtr
```

Parsed in Lua as:
```lua
symbols["gPlayerPartyCount"] = 0x02024744
symbols["gPlayerParty"] = 0x02024748
```

## Memory Reading Process

### 1. Address Translation

GBA memory regions:
- EWRAM: `0x02000000` - `0x0203FFFF` (256KB)
- IWRAM: `0x03000000` - `0x03007FFF` (32KB)
- ROM: `0x08000000` - `0x0DFFFFFF` (96MB)

To read from a symbol:
```lua
local addr = symbols["gPlayerParty"]  -- 0x02024748
local region, offset = addressToRegion(addr)
-- region = ewram, offset = 0x24748

local value = region:read8(offset)
```

### 2. Pokemon Data Structure

```
struct Pokemon (100 bytes total)
├─ struct BoxPokemon box (80 bytes)
│  ├─ u32 personality         @ +0    [4 bytes]
│  ├─ u32 otId                @ +4    [4 bytes]
│  ├─ char nickname[10]       @ +8    [10 bytes]
│  ├─ u8 language             @ +18   [1 byte]
│  ├─ char otName[7]          @ +19   [7 bytes]
│  ├─ u8 markings             @ +27   [1 byte]
│  ├─ u16 checksum            @ +28   [2 bytes]
│  ├─ u16 unknown             @ +30   [2 bytes]
│  └─ ENCRYPTED DATA (48 bytes) @ +32
│     ├─ Growth substruct     [12 bytes] - species, experience, items
│     ├─ Attacks substruct    [12 bytes] - moves, PP
│     ├─ EVs substruct        [12 bytes] - EVs, contest stats
│     └─ Misc substruct       [12 bytes] - IVs, ribbons, origins
│
├─ u32 status                 @ +80   [4 bytes]
├─ u8 level                   @ +84   [1 byte]
├─ u8 mail                    @ +85   [1 byte]
├─ u16 hp                     @ +86   [2 bytes]
├─ u16 maxHP                  @ +88   [2 bytes]
├─ u16 attack                 @ +90   [2 bytes]
├─ u16 defense                @ +92   [2 bytes]
├─ u16 speed                  @ +94   [2 bytes]
├─ u16 spAttack               @ +96   [2 bytes]
└─ u16 spDefense              @ +98   [2 bytes]
```

### 3. Encryption/Decryption

Pokemon data (48 bytes from offset +32 in BoxPokemon) is encrypted:

**Encryption Key**: `personality XOR otId`

**Decryption Algorithm**:
```lua
function decrypt(encryptedBytes, personality, otId)
    local key = personality ~ otId
    local decrypted = {}

    for i = 0, 47, 4 do
        local encrypted32 = read32(encryptedBytes, i)
        local decrypted32 = encrypted32 ~ key

        -- Store as bytes
        decrypted[i+0] = (decrypted32 >> 0) & 0xFF
        decrypted[i+1] = (decrypted32 >> 8) & 0xFF
        decrypted[i+2] = (decrypted32 >> 16) & 0xFF
        decrypted[i+3] = (decrypted32 >> 24) & 0xFF

        -- Advance PRNG
        key = (key * 0x41C64E6D + 0x6073) & 0xFFFFFFFF
    end

    return unscramble(decrypted, personality % 24)
end
```

**Unscrambling**: The 48 bytes are divided into 4×12-byte substructures stored in scrambled order based on `personality % 24`.

### 4. Substruct Parsing

After decryption and unscrambling, parse each 12-byte substruct:

**Growth** (bytes 0-11):
```
+0: u16 species
+2: u16 heldItem
+4: u32 experience
+8: u8 ppBonuses
+9: u8 friendship
```

**Attacks** (bytes 12-23):
```
+0: u16 move1
+2: u16 move2
+4: u16 move3
+6: u16 move4
+8: u8 pp1
+9: u8 pp2
+10: u8 pp3
+11: u8 pp4
```

**EVs** (bytes 24-35):
```
+0: u8 hpEV
+1: u8 attackEV
+2: u8 defenseEV
+3: u8 speedEV
+4: u8 spAttackEV
+5: u8 spDefenseEV
+6-11: contest stats
```

**Misc** (bytes 36-47):
```
+0: u8 pokerus
+1: u8 metLocation
+2: u16 origins (level, game, pokeball, OT gender packed)
+4: u32 IVs + egg + ability (all packed)
+8: u32 ribbons
```

## Badge Reading

Badges are stored as bit flags in `gSaveBlock1Ptr->flags[]` array.

Flag IDs (from `include/constants/flags.h`):
```
FLAG_BADGE01_GET = 0x867  (Stone Badge)
FLAG_BADGE02_GET = 0x868  (Knuckle Badge)
...
FLAG_BADGE08_GET = 0x86E  (Rain Badge)
```

To check if badge is obtained:
```lua
local flagId = 0x867
local byteOffset = math.floor(flagId / 8)  -- = 268
local bitOffset = flagId % 8              -- = 7

local byte = read8(flagsBaseAddr + byteOffset)
local obtained = ((byte >> bitOffset) & 1) == 1
```

## Performance Considerations

### Update Frequency
- Default: 60 frames (1 second at 60 FPS)
- Recommended range: 60-120 frames
- Trade-off: Faster = more responsive, slower = less CPU

### Memory Access Costs
| Operation | Time Complexity | Notes |
|-----------|-----------------|-------|
| Read party (6 Pokemon) | O(1) | ~600 bytes total |
| Decrypt 1 Pokemon | O(1) | 48 bytes, 12 XOR operations |
| Read current box | O(1) | ~2400 bytes (30 slots) |
| Read all boxes | O(1) | ~33KB (420 Pokemon) |
| Symbol lookup | O(1) | Hash table |

### Optimizations Implemented
1. **Lazy box reading**: Only read current box by default
2. **Cached symbols**: Load symbol file once at init
3. **Direct memory access**: No intermediate copies
4. **Efficient JSON**: Simple string concatenation instead of library

## Data Tables Generation

The `generate_data_tables.sh` script:

```bash
#!/bin/bash
grep "^#define SPECIES_" include/constants/species.h | \
while read line; do
    name=$(echo "$line" | awk '{print $2}' | sed 's/SPECIES_//')
    id=$(echo "$line" | awk '{print $3}')
    echo "    [$id] = \"$name\","
done
```

This creates a Lua table mapping species IDs to names:
```lua
local SPECIES_NAMES = {
    [1] = "BULBASAUR",
    [2] = "IVYSAUR",
    ...
    [1622] = "CALYREX_ICE_RIDER",
}
```

Same process for moves.

## Frontend Update Mechanism

The frontend uses polling instead of WebSockets for simplicity:

```javascript
async function updateData() {
    const url = `tracker_data.json?t=${Date.now()}`;  // Cache-bust
    const response = await fetch(url);
    const data = await response.json();
    updateUI(data);
}

setInterval(updateData, 1000);
```

**Pros**:
- Simple to implement
- No server required
- Works with file:// protocol (mostly)

**Cons**:
- 1-second latency
- File I/O every second
- May hit browser security restrictions

**Future Enhancement**: Use WebSocket for instant updates.

## Error Handling

### Lua Script
1. **Symbol not found**: Returns `nil`, logs error, continues
2. **Memory read fails**: Returns 0 or empty string
3. **Invalid data**: Skips Pokemon (species = 0)
4. **File write fails**: Logs error, retries next frame

### Frontend
1. **Fetch fails**: Shows "Disconnected" status
2. **JSON parse fails**: Keeps old data, logs error
3. **Missing fields**: Uses default values (-, 0, empty)
4. **Browser security**: Suggests local web server

## Testing

### Unit Testing (Manual)

**Test Symbol Loading**:
```lua
-- In mGBA console
symbols = loadSymbols("pokeemerald.sym")
print(symbols["gPlayerParty"])  -- Should show address
```

**Test Memory Reading**:
```lua
local count = read8(symbols["gPlayerPartyCount"])
print("Party count:", count)  -- Should match actual party
```

**Test Decryption**:
```lua
local mon = readPokemon(symbols["gPlayerParty"])
print("Species:", mon.species)  -- Should match first Pokemon
```

### Integration Testing

1. **Sample Data Test**:
   ```bash
   cp tracker_data_sample.json tracker_data.json
   # Open frontend, should show sample party
   ```

2. **Live Test**:
   ```bash
   # Load script in mGBA, verify:
   - tracker_data.json is created
   - File size grows/changes
   - Frontend shows live data
   ```

## Known Issues & Workarounds

### Issue: CORS Errors
**Symptom**: Frontend can't load tracker_data.json

**Cause**: Browser security blocks file:// from fetching local files

**Workaround**: Use local web server:
```bash
python3 -m http.server 8000
```

### Issue: Stale Symbol Addresses
**Symptom**: Wrong data or crashes after recompiling

**Cause**: Memory addresses changed but using old .sym file

**Workaround**: Always regenerate symbols after building:
```bash
make && make syms && cp pokeemerald.sym mgba_scripts/
```

### Issue: Box Pokemon Show Wrong Species
**Symptom**: PC box Pokemon have incorrect names

**Cause**: BoxPokemon data is encrypted, current implementation reads species directly

**Fix**: Implement full decryption for BoxPokemon (not just party Pokemon)

### Issue: Missing Pokemon After Reorder
**Symptom**: Party updates lag behind actual game

**Cause**: 1-second update interval

**Workaround**: Decrease `UPDATE_INTERVAL` to 30 frames (0.5 seconds)

## Security Considerations

1. **No network access**: All data stays local
2. **Read-only**: Script never writes to game memory
3. **No code injection**: Pure data reading
4. **File permissions**: JSON written to script directory only

## Future Enhancements

### High Priority
- [ ] Full BoxPokemon decryption
- [ ] WebSocket server for instant updates
- [ ] Pokemon sprite display
- [ ] Error recovery (auto-reload symbols)

### Medium Priority
- [ ] Type effectiveness calculator
- [ ] Nature/ability display
- [ ] IV/EV visualization
- [ ] Move PP tracking
- [ ] Status condition display

### Low Priority
- [ ] Battle statistics
- [ ] Pokedex completion tracker
- [ ] Item inventory display
- [ ] Money/coin tracking
- [ ] Save file metadata

## References

- **mGBA Scripting API**: https://mgba.io/docs/scripting.html
- **Gen 3 Data Structures**: https://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_data_structure_(Generation_III)
- **Gen 3 Save Structure**: https://bulbapedia.bulbagarden.net/wiki/Save_data_structure_(Generation_III)
- **pokeemerald Source**: https://github.com/pret/pokeemerald
- **Symbol Format**: No$GBA .sym specification

## License

This implementation is provided as-is for educational and personal use with pokeemerald-expansion.
